# Microkernel

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/OS-structure.svg/450px-OS-structure.svg.png)](https://en.wikipedia.org/wiki/File:OS-structure.svg)

In [computer science](https://en.wikipedia.org/wiki/Computer_science), a **microkernel** (often abbreviated as **Î¼-kernel**) is the near-minimum amount of [software](https://en.wikipedia.org/wiki/Software) that can provide the mechanisms needed to implement an [operating system](https://en.wikipedia.org/wiki/Operating_system) (OS). These mechanisms include low-level [address space](https://en.wikipedia.org/wiki/Address_space) management, [thread](https://en.wikipedia.org/wiki/Thread_(computing)) management, and [inter-process communication](https://en.wikipedia.org/wiki/Inter-process_communication) (IPC).

If the hardware provides multiple [rings](https://en.wikipedia.org/wiki/Protection_ring) or [CPU modes](https://en.wikipedia.org/wiki/CPU_modes), the microkernel may be the only software executing at the most privileged level, which is generally referred to as [supervisor or kernel mode](https://en.wikipedia.org/wiki/Kernel_mode). Traditional operating system functions, such as [device drivers](https://en.wikipedia.org/wiki/Device_driver), [protocol stacks](https://en.wikipedia.org/wiki/Protocol_stack) and [file systems](https://en.wikipedia.org/wiki/File_system), are typically removed from the microkernel itself and are instead run in [user space](https://en.wikipedia.org/wiki/User_space).[[1\]](https://en.wikipedia.org/wiki/Microkernel#cite_note-1)

In terms of the source code size, microkernels are often smaller than [monolithic kernels](https://en.wikipedia.org/wiki/Monolithic_kernel). The [MINIX 3](https://en.wikipedia.org/wiki/MINIX_3) microkernel, for example, has only approximately 12,000 lines of code.



## Inter-process communication[[edit](https://en.wikipedia.org/w/index.php?title=Microkernel&action=edit&section=3)]

[Inter-process communication](https://en.wikipedia.org/wiki/Inter-process_communication) (IPC) is any mechanism which allows separate processes to communicate with each other, usually by sending [messages](https://en.wikipedia.org/wiki/Message_passing). [Shared memory](https://en.wikipedia.org/wiki/Shared_memory) is, strictly defined, also an inter-process communication mechanism, but the abbreviation IPC usually refers to message passing only, and it is the latter that is particularly relevant to microkernels. IPC allows the operating system to be built from a number of smaller programs called servers, which are used by other programs on the system, invoked via IPC. Most or all support for peripheral hardware is handled in this fashion, with servers for device drivers, [network protocol stacks](https://en.wikipedia.org/wiki/Network_protocol_stack), file systems, graphics, etc.

IPC can be synchronous or asynchronous. Asynchronous IPC is analogous to network communication: the sender dispatches a message and continues executing. The receiver checks ([polls](https://en.wikipedia.org/wiki/Polling_(computer_science))) for the availability of the message, or is alerted to it via some notification mechanism. Asynchronous IPC requires that the kernel maintains buffers and queues for messages, and deals with buffer overflows; it also requires double copying of messages (sender to kernel and kernel to receiver). In synchronous IPC, the first party (sender or receiver) blocks until the other party is ready to perform the IPC. It does not require buffering or multiple copies, but the implicit rendezvous can make programming tricky. Most programmers prefer asynchronous send and synchronous receive.

Asynchronous IPC could be implemented on top by using helper threads. However, experience has shown that the utility of synchronous IPC is dubious: synchronous IPC forces a multi-threaded design onto otherwise simple systems, with the resulting synchronization complexities. Moreover, an RPC-like server invocation sequentializes client and server, which should be avoided if they are running on separate cores. Versions of L4 deployed in commercial products have therefore found it necessary to add an asynchronous notification mechanism to better support asynchronous communication. This [signal](https://en.wikipedia.org/wiki/Signal_(computing))-like mechanism does not carry data and therefore does not require buffering by the kernel. 